# 闭包

## 闭包的产生

当一个嵌套的内部（子）函数引用了嵌套的外部（父）函数的变量（函数）时，就产生了闭包

## 闭包到底是什么

使用chrome调试查看
理解一：闭包是嵌套的内部函数（不太准确）
理解二：包含被引用变量（函数）的**对象**
**注意：闭包存在于嵌套的内部函数中**

## 闭包产生的条件

- 函数嵌套
- 内部函数引用了外部函数的数据（变量/函数）

```js
function fn1(){
  // 此时闭包就已经产生了（函数提升，内部函数对象已经创建了）
  var a = 2
  function fn2(){
    a++
    console.log(a)
  }
  return fn2
}
var f = fn1()
f() // 3
f() // 4
```

以上代码，虽然f调用了两次，但实际上只产生了一个闭包

## 闭包的作用

1. 使函数内部的变量在函数执行完后，仍然存活在内存中（延长了局部变量的生命周期）
2. 让函数外部可以操作（读写）到函数内部的数据（变量/函数）

 问题：

1. 函数执行完后，函数内部声明的局部变量是否还存在？
   一般是不存在，存在于闭包中的还存在，例如上面代码中的变量a
2. 在函数外部能直接访问函数内部的局部变量吗？
   不能，但是可以通过闭包让外部操作它

## 闭包的生命周期

- 产生：在嵌套内部函数**定义执行完成时**就产生了（不是在调用）
  例如上面的代码中，在fn1定义时，代码走到第3行时，闭包就已经产生，由于函数提升，fn2的定义已经执行完成
- 死亡：在嵌套的内部函数成为垃圾对象时
  在上面的代码中最后添加一行代码  f=null 后，闭包死亡

## 闭包应用

- 定义JS模块
  - 具有特定功能的js文件
  - 将所有的数据和功能都封装在一个函数内部（私有的）
  - 只向外暴露一个包含n个方法的对象或函数
  - 模块的使用者，只需通过暴露的对象调用方法来实现对应的功能

```js
(function (){
  var msg = 'My atguigu'
  function doSomething() {
    console.log('doSomething() ' + msg.toUpperCase())
  }
  function doOtherthing() {
    console.log('doOtherthing() ' + msg.toUpperCase())
  }
  
  // 向外暴露对象（）
  window.myModule2 = {
    doSomething: doSomething,
    doOtherthing: doOtherthing
  }
})()
```

## 闭包的缺点及解决

- 缺点
  - 函数执行完后，函数内部的局部变量没有释放，占用内存时间会变长
  - 容易曹成内存泄漏
- 解决方式
  - 不用闭包
  - 及时释放